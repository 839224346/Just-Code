|题号|题目名称|通关率|难度|zc打卡|jdq打卡|
|---|---|---|---|---|---|
|5|[Longest Palindromic Substring](#5-longest-palindromic-substring)<span id = 5></span>|29.3%|Medium|||
|10|[Regular Expression Matching](#10-regular-expression-matching)<span id = 10></span>|26.7%|Hard|||
|32|[Longest Valid Parentheses](#32-longest-valid-parentheses)<span id = 32></span>|28.2%|Hard|||
|44|[Wildcard Matching](#44-wildcard-matching)<span id = 44></span>|24.6%|Hard|||
|53|[Maximum Subarray](#53-maximum-subarray)<span id = 53></span>|46.4%|Easy|||
|62|[Unique Paths](#62-unique-paths)<span id = 62></span>|53.8%|Medium|2020.07.15||
|63|[Unique Paths II](#63-unique-paths-ii)<span id = 63></span>|34.4%|Medium|2020.07.15||
|64|[Minimum Path Sum](#64-minimum-path-sum)<span id = 64></span>|54.1%|Medium|2020.07.15||
|70|[Climbing Stairs](#70-climbing-stairs)<span id = 70></span>|47.1%|Easy|2020.07.15||
|72|[Edit Distance](#72-edit-distance)<span id = 72></span>|44.4%|Hard|2020.07.15||
|85|[Maximal Rectangle](#85-maximal-rectangle)<span id = 85></span>|37.4%|Hard|||
|87|[Scramble String](#87-scramble-string)<span id = 87></span>|33.6%|Hard|||
|91|[Decode Ways](#91-decode-ways)<span id = 91></span>|24.5%|Medium|||
|95|[Unique Binary Search Trees II](#95-unique-binary-search-trees-ii)<span id = 95></span>|40.3%|Medium|||
|96|[Unique Binary Search Trees](#96-unique-binary-search-trees)<span id = 96></span>|52.5%|Medium|2020.07.15|2020.07.19|
|97|[Interleaving String](#97-interleaving-string)<span id = 97></span>|31.3%|Hard|||
|115|[Distinct Subsequences](#115-distinct-subsequences)<span id = 115></span>|38.0%|Hard|||
|120|[Triangle](#120-triangle)<span id = 120></span>|43.8%|Medium|2020.07.16|2020.07.16|
|121|[Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)<span id = 121></span>|50.3%|Easy|2020.07.16||
|123|[Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)<span id = 123></span>|37.2%|Hard|||
|132|[Palindrome Partitioning II](#132-palindrome-partitioning-ii)<span id = 132></span>|30.1%|Hard|||
|139|[Word Break](#139-word-break)<span id = 139></span>|39.7%|Medium|||
|140|[Word Break II](#140-word-break-ii)<span id = 140></span>|31.5%|Hard|||
|152|[Maximum Product Subarray](#152-maximum-product-subarray)<span id = 152></span>|31.5%|Medium|||
|174|[Dungeon Game](#174-dungeon-game)<span id = 174></span>|32.1%|Hard|||
|188|[Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)<span id = 188></span>|27.9%|Hard|||
|198|[House Robber](#198-house-robber)<span id = 198></span>|41.9%|Easy|||
|213|[House Robber II](#213-house-robber-ii)<span id = 213></span>|36.4%|Medium|||
|221|[Maximal Square](#221-maximal-square)<span id = 221></span>|37.6%|Medium|||
|256|[Paint House](#256-paint-house)<span id = 256></span>|52.0%|Easy|||
|264|[Ugly Number II](#264-ugly-number-ii)<span id = 264></span>|41.9%|Medium|||
|265|[Paint House II](#265-paint-house-ii)<span id = 265></span>|44.5%|Hard|||
|276|[Paint Fence](#276-paint-fence)<span id = 276></span>|38.1%|Easy|||
|279|[Perfect Squares](#279-perfect-squares)<span id = 279></span>|47.1%|Medium|||
|300|[Longest Increasing Subsequence](#300-longest-increasing-subsequence)<span id = 300></span>|42.5%|Medium|||
|303|[Range Sum Query - Immutable](#303-range-sum-query---immutable)<span id = 303></span>|44.2%|Easy|||
|304|[Range Sum Query 2D - Immutable](#304-range-sum-query-2d---immutable)<span id = 304></span>|38.1%|Medium|||
|309|[Best Time to Buy and Sell Stock with Cooldown](#309-best-time-to-buy-and-sell-stock-with-cooldown)<span id = 309></span>|46.3%|Medium|||
|312|[Burst Balloons](#312-burst-balloons)<span id = 312></span>|51.4%|Hard|||
|321|[Create Maximum Number](#321-create-maximum-number)<span id = 321></span>|26.9%|Hard|||
|322|[Coin Change](#322-coin-change)<span id = 322></span>|35.1%|Medium|||
|338|[Counting Bits](#338-counting-bits)<span id = 338></span>|69.3%|Medium|||
|343|[Integer Break](#343-integer-break)<span id = 343></span>|50.1%|Medium|||
|351|[Android Unlock Patterns](#351-android-unlock-patterns)<span id = 351></span>|48.2%|Medium|||
|354|[Russian Doll Envelopes](#354-russian-doll-envelopes)<span id = 354></span>|35.5%|Hard|||
|357|[Count Numbers with Unique Digits](#357-count-numbers-with-unique-digits)<span id = 357></span>|48.2%|Medium|||
|361|[Bomb Enemy](#361-bomb-enemy)<span id = 361></span>|45.9%|Medium|||
|363|[Max Sum of Rectangle No Larger Than K](#363-max-sum-of-rectangle-no-larger-than-k)<span id = 363></span>|37.2%|Hard|||
|368|[Largest Divisible Subset](#368-largest-divisible-subset)<span id = 368></span>|38.1%|Medium|||
|375|[Guess Number Higher or Lower II](#375-guess-number-higher-or-lower-ii)<span id = 375></span>|40.2%|Medium|||
|376|[Wiggle Subsequence](#376-wiggle-subsequence)<span id = 376></span>|39.5%|Medium|||
|377|[Combination Sum IV](#377-combination-sum-iv)<span id = 377></span>|45.2%|Medium|||
|392|[Is Subsequence](#392-is-subsequence)<span id = 392></span>|49.1%|Easy|||
|403|[Frog Jump](#403-frog-jump)<span id = 403></span>|39.5%|Hard|||
|410|[Split Array Largest Sum](#410-split-array-largest-sum)<span id = 410></span>|44.4%|Hard|||
|413|[Arithmetic Slices](#413-arithmetic-slices)<span id = 413></span>|57.8%|Medium|||
|416|[Partition Equal Subset Sum](#416-partition-equal-subset-sum)<span id = 416></span>|43.5%|Medium|||
|418|[Sentence Screen Fitting](#418-sentence-screen-fitting)<span id = 418></span>|32.6%|Medium|||
|446|[Arithmetic Slices II - Subsequence](#446-arithmetic-slices-ii---subsequence)<span id = 446></span>|32.6%|Hard|||
|464|[Can I Win](#464-can-i-win)<span id = 464></span>|28.8%|Medium|||
|466|[Count The Repetitions](#466-count-the-repetitions)<span id = 466></span>|28.2%|Hard|||
|467|[Unique Substrings in Wraparound String](#467-unique-substrings-in-wraparound-string)<span id = 467></span>|35.5%|Medium|||
|471|[Encode String with Shortest Length](#471-encode-string-with-shortest-length)<span id = 471></span>|47.0%|Hard|||
|472|[Concatenated Words](#472-concatenated-words)<span id = 472></span>|43.3%|Hard|||
|474|[Ones and Zeroes](#474-ones-and-zeroes)<span id = 474></span>|42.6%|Medium|||
|486|[Predict the Winner](#486-predict-the-winner)<span id = 486></span>|47.8%|Medium|||
|494|[Target Sum](#494-target-sum)<span id = 494></span>|46.4%|Medium|||
|514|[Freedom Trail](#514-freedom-trail)<span id = 514></span>|42.8%|Hard|||
|516|[Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)<span id = 516></span>|52.8%|Medium|||
|517|[Super Washing Machines](#517-super-washing-machines)<span id = 517></span>|38.2%|Hard|||
|523|[Continuous Subarray Sum](#523-continuous-subarray-sum)<span id = 523></span>|24.6%|Medium|||
|546|[Remove Boxes](#546-remove-boxes)<span id = 546></span>|42.3%|Hard|||
|552|[Student Attendance Record II](#552-student-attendance-record-ii)<span id = 552></span>|36.5%|Hard|||
|568|[Maximum Vacation Days](#568-maximum-vacation-days)<span id = 568></span>|40.7%|Hard|||
|576|[Out of Boundary Paths](#576-out-of-boundary-paths)<span id = 576></span>|34.9%|Medium|||
|600|[Non-negative Integers without Consecutive Ones](#600-non-negative-integers-without-consecutive-ones)<span id = 600></span>|34.0%|Hard|||
|629|[K Inverse Pairs Array](#629-k-inverse-pairs-array)<span id = 629></span>|31.0%|Hard|||
|638|[Shopping Offers](#638-shopping-offers)<span id = 638></span>|51.3%|Medium|||
|639|[Decode Ways II](#639-decode-ways-ii)<span id = 639></span>|26.4%|Hard|||
|646|[Maximum Length of Pair Chain](#646-maximum-length-of-pair-chain)<span id = 646></span>|51.6%|Medium|||
|647|[Palindromic Substrings](#647-palindromic-substrings)<span id = 647></span>|60.4%|Medium|||
|650|[2 Keys Keyboard](#650-2-keys-keyboard)<span id = 650></span>|48.9%|Medium|||
|651|[4 Keys Keyboard](#651-4-keys-keyboard)<span id = 651></span>|52.4%|Medium|||
|656|[Coin Path](#656-coin-path)<span id = 656></span>|28.9%|Hard|||
|664|[Strange Printer](#664-strange-printer)<span id = 664></span>|40.0%|Hard|||
|673|[Number of Longest Increasing Subsequence](#673-number-of-longest-increasing-subsequence)<span id = 673></span>|35.6%|Medium|||
|688|[Knight Probability in Chessboard](#688-knight-probability-in-chessboard)<span id = 688></span>|48.6%|Medium|||
|689|[Maximum Sum of 3 Non-Overlapping Subarrays](#689-maximum-sum-of-3-non-overlapping-subarrays)<span id = 689></span>|46.0%|Hard|||
|691|[Stickers to Spell Word](#691-stickers-to-spell-word)<span id = 691></span>|42.6%|Hard|||
|698|[Partition to K Equal Sum Subsets](#698-partition-to-k-equal-sum-subsets)<span id = 698></span>|45.0%|Medium|||
|712|[Minimum ASCII Delete Sum for Two Strings](#712-minimum-ascii-delete-sum-for-two-strings)<span id = 712></span>|58.4%|Medium|||
|714|[Best Time to Buy and Sell Stock with Transaction Fee](#714-best-time-to-buy-and-sell-stock-with-transaction-fee)<span id = 714></span>|54.3%|Medium|||
|718|[Maximum Length of Repeated Subarray](#718-maximum-length-of-repeated-subarray)<span id = 718></span>|49.3%|Medium|||
|727|[Minimum Window Subsequence](#727-minimum-window-subsequence)<span id = 727></span>|41.5%|Hard|||
|730|[Count Different Palindromic Subsequences](#730-count-different-palindromic-subsequences)<span id = 730></span>|41.6%|Hard|||
|740|[Delete and Earn](#740-delete-and-earn)<span id = 740></span>|48.5%|Medium|||
|741|[Cherry Pickup](#741-cherry-pickup)<span id = 741></span>|33.9%|Hard|||
|746|[Min Cost Climbing Stairs](#746-min-cost-climbing-stairs)<span id = 746></span>|50.2%|Easy|||
|750|[Number Of Corner Rectangles](#750-number-of-corner-rectangles)<span id = 750></span>|66.4%|Medium|||
|764|[Largest Plus Sign](#764-largest-plus-sign)<span id = 764></span>|46.0%|Medium|||
|787|[Cheapest Flights Within K Stops](#787-cheapest-flights-within-k-stops)<span id = 787></span>|39.3%|Medium|||
|790|[Domino and Tromino Tiling](#790-domino-and-tromino-tiling)<span id = 790></span>|39.0%|Medium|||
|801|[Minimum Swaps To Make Sequences Increasing](#801-minimum-swaps-to-make-sequences-increasing)<span id = 801></span>|38.8%|Medium|||
|808|[Soup Servings](#808-soup-servings)<span id = 808></span>|39.7%|Medium|||
|813|[Largest Sum of Averages](#813-largest-sum-of-averages)<span id = 813></span>|49.7%|Medium|||
|818|[Race Car](#818-race-car)<span id = 818></span>|38.7%|Hard|||
|837|[New 21 Game](#837-new-21-game)<span id = 837></span>|34.5%|Medium|||
|838|[Push Dominoes](#838-push-dominoes)<span id = 838></span>|48.2%|Medium|||
|847|[Shortest Path Visiting All Nodes](#847-shortest-path-visiting-all-nodes)<span id = 847></span>|51.7%|Hard|||
|871|[Minimum Number of Refueling Stops](#871-minimum-number-of-refueling-stops)<span id = 871></span>|31.2%|Hard|||
|873|[Length of Longest Fibonacci Subsequence](#873-length-of-longest-fibonacci-subsequence)<span id = 873></span>|47.6%|Medium|||
|877|[Stone Game](#877-stone-game)<span id = 877></span>|64.5%|Medium|||
|879|[Profitable Schemes](#879-profitable-schemes)<span id = 879></span>|39.6%|Hard|||
|887|[Super Egg Drop](#887-super-egg-drop)<span id = 887></span>|27.1%|Hard|||
|898|[Bitwise ORs of Subarrays](#898-bitwise-ors-of-subarrays)<span id = 898></span>|35.0%|Medium|||
|902|[Numbers At Most N Given Digit Set](#902-numbers-at-most-n-given-digit-set)<span id = 902></span>|31.4%|Hard|||
|903|[Valid Permutations for DI Sequence](#903-valid-permutations-for-di-sequence)<span id = 903></span>|49.5%|Hard|||
|920|[Number of Music Playlists](#920-number-of-music-playlists)<span id = 920></span>|46.4%|Hard|||
|931|[Minimum Falling Path Sum](#931-minimum-falling-path-sum)<span id = 931></span>|62.2%|Medium|2020.07.16||
|935|[Knight Dialer](#935-knight-dialer)<span id = 935></span>|44.9%|Medium|||
|940|[Distinct Subsequences II](#940-distinct-subsequences-ii)<span id = 940></span>|41.5%|Hard|||
|943|[Find the Shortest Superstring](#943-find-the-shortest-superstring)<span id = 943></span>|42.7%|Hard|||
|956|[Tallest Billboard](#956-tallest-billboard)<span id = 956></span>|39.7%|Hard|||
|960|[Delete Columns to Make Sorted III](#960-delete-columns-to-make-sorted-iii)<span id = 960></span>|53.6%|Hard|||
|964|[Least Operators to Express Number](#964-least-operators-to-express-number)<span id = 964></span>|43.7%|Hard|||
|967|[Numbers With Same Consecutive Differences](#967-numbers-with-same-consecutive-differences)<span id = 967></span>|39.2%|Medium|||
|968|[Binary Tree Cameras](#968-binary-tree-cameras)<span id = 968></span>|37.2%|Hard|||
|975|[Odd Even Jump](#975-odd-even-jump)<span id = 975></span>|42.5%|Hard|||
|978|[Longest Turbulent Subarray](#978-longest-turbulent-subarray)<span id = 978></span>|46.5%|Medium|||
|982|[Triples with Bitwise AND Equal To Zero](#982-triples-with-bitwise-and-equal-to-zero)<span id = 982></span>|55.6%|Hard|||
|983|[Minimum Cost For Tickets](#983-minimum-cost-for-tickets)<span id = 983></span>|60.1%|Medium|||
|1000|[Minimum Cost to Merge Stones](#1000-minimum-cost-to-merge-stones)<span id = 1000></span>|39.5%|Hard|||
|1055|[Shortest Way to Form String](#1055-shortest-way-to-form-string)<span id = 1055></span>|57.0%|Medium|||
|1058|[Minimize Rounding Error to Meet Target](#1058-minimize-rounding-error-to-meet-target)<span id = 1058></span>|41.8%|Medium|||
|1012|[Numbers With Repeated Digits](#1012-numbers-with-repeated-digits)<span id = 1012></span>|37.4%|Hard|||
|1066|[Campus Bikes II](#1066-campus-bikes-ii)<span id = 1066></span>|54.3%|Medium|||
|1067|[Digit Count in Range](#1067-digit-count-in-range)<span id = 1067></span>|39.8%|Hard|||
|1024|[Video Stitching](#1024-video-stitching)<span id = 1024></span>|49.1%|Medium|||
|1025|[Divisor Game](#1025-divisor-game)<span id = 1025></span>|66.2%|Easy|||
|1027|[Longest Arithmetic Sequence](#1027-longest-arithmetic-sequence)<span id = 1027></span>|53.5%|Medium|||
|1136|[Parallel Courses](#1136-parallel-courses)<span id = 1136></span>|61.0%|Hard|||
|1039|[Minimum Score Triangulation of Polygon](#1039-minimum-score-triangulation-of-polygon)<span id = 1039></span>|48.7%|Medium|||
|1048|[Longest String Chain](#1048-longest-string-chain)<span id = 1048></span>|54.5%|Medium|||
|1049|[Last Stone Weight II](#1049-last-stone-weight-ii)<span id = 1049></span>|44.0%|Medium|||
|1074|[Number of Submatrices That Sum to Target](#1074-number-of-submatrices-that-sum-to-target)<span id = 1074></span>|59.0%|Hard|||
|1230|[Toss Strange Coins](#1230-toss-strange-coins)<span id = 1230></span>|48.3%|Medium|||
|1199|[Minimum Time to Build Blocks](#1199-minimum-time-to-build-blocks)<span id = 1199></span>|37.1%|Hard|||
|1092|[Shortest Common Supersequence](#1092-shortest-common-supersequence)<span id = 1092></span>|51.1%|Hard|||
|1216|[Valid Palindrome III](#1216-valid-palindrome-iii)<span id = 1216></span>|47.7%|Hard|||
|1105|[Filling Bookcase Shelves](#1105-filling-bookcase-shelves)<span id = 1105></span>|58.2%|Medium|||
|1273|[Delete Tree Nodes](#1273-delete-tree-nodes)<span id = 1273></span>|63.4%|Medium|||
|1246|[Palindrome Removal](#1246-palindrome-removal)<span id = 1246></span>|46.0%|Hard|||
|1259|[Handshakes That Don't Cross](#1259-handshakes-that-don't-cross)<span id = 1259></span>|53.3%|Hard|||
|1125|[Smallest Sufficient Team](#1125-smallest-sufficient-team)<span id = 1125></span>|46.4%|Hard|||
|1289|[Minimum Falling Path Sum II](#1289-minimum-falling-path-sum-ii)<span id = 1289></span>|60.7%|Hard|2020.07.16||
|1130|[Minimum Cost Tree From Leaf Values](#1130-minimum-cost-tree-from-leaf-values)<span id = 1130></span>|65.9%|Medium|||
|1301|[Number of Paths with Max Score](#1301-number-of-paths-with-max-score)<span id = 1301></span>|37.1%|Hard|||
|1139|[Largest 1-Bordered Square](#1139-largest-1-bordered-square)<span id = 1139></span>|47.2%|Medium|||
|1140|[Stone Game II](#1140-stone-game-ii)<span id = 1140></span>|62.8%|Medium|||
|1314|[Matrix Block Sum](#1314-matrix-block-sum)<span id = 1314></span>|73.8%|Medium|||
|1143|[Longest Common Subsequence](#1143-longest-common-subsequence)<span id = 1143></span>|58.4%|Medium|||
|1147|[Longest Chunked Palindrome Decomposition](#1147-longest-chunked-palindrome-decomposition)<span id = 1147></span>|58.5%|Hard|||
|1155|[Number of Dice Rolls With Target Sum](#1155-number-of-dice-rolls-with-target-sum)<span id = 1155></span>|49.2%|Medium|||
|1363|[Largest Multiple of Three](#1363-largest-multiple-of-three)<span id = 1363></span>|33.4%|Hard|||
|1425|[Constrained Subsequence Sum](#1425-constrained-subsequence-sum)<span id = 1425></span>|43.9%|Hard|||
|1186|[Maximum Subarray Sum with One Deletion](#1186-maximum-subarray-sum-with-one-deletion)<span id = 1186></span>|37.2%|Medium|||
|1187|[Make Array Strictly Increasing](#1187-make-array-strictly-increasing)<span id = 1187></span>|41.6%|Hard|||
|1483|[Kth Ancestor of a Tree Node](#1483-kth-ancestor-of-a-tree-node)<span id = 1483></span>|26.9%|Hard|||
|1191|[K-Concatenation Maximum Sum](#1191-k-concatenation-maximum-sum)<span id = 1191></span>|25.9%|Medium|||
|1405|[Longest Happy String](#1405-longest-happy-string)<span id = 1405></span>|48.0%|Medium|||
|1218|[Longest Arithmetic Subsequence of Given Difference](#1218-longest-arithmetic-subsequence-of-given-difference)<span id = 1218></span>|44.0%|Medium|||
|1220|[Count Vowels Permutation](#1220-count-vowels-permutation)<span id = 1220></span>|53.6%|Hard|||
|1223|[Dice Roll Simulation](#1223-dice-roll-simulation)<span id = 1223></span>|45.5%|Medium|||
|1235|[Maximum Profit in Job Scheduling](#1235-maximum-profit-in-job-scheduling)<span id = 1235></span>|44.3%|Hard|||
|1240|[Tiling a Rectangle with the Fewest Squares](#1240-tiling-a-rectangle-with-the-fewest-squares)<span id = 1240></span>|49.4%|Hard|||
|1227|[Airplane Seat Assignment Probability](#1227-airplane-seat-assignment-probability)<span id = 1227></span>|60.5%|Medium|||
|1262|[Greatest Sum Divisible by Three](#1262-greatest-sum-divisible-by-three)<span id = 1262></span>|47.4%|Medium|||
|1269|[Number of Ways to Stay in the Same Place After Some Steps](#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps)<span id = 1269></span>|43.0%|Hard|||
|1277|[Count Square Submatrices with All Ones](#1277-count-square-submatrices-with-all-ones)<span id = 1277></span>|72.9%|Medium|||
|1278|[Palindrome Partitioning III](#1278-palindrome-partitioning-iii)<span id = 1278></span>|59.7%|Hard|||
|1312|[Minimum Insertion Steps to Make a String Palindrome](#1312-minimum-insertion-steps-to-make-a-string-palindrome)<span id = 1312></span>|57.7%|Hard|||
|1320|[Minimum Distance to Type a Word Using Two Fingers](#1320-minimum-distance-to-type-a-word-using-two-fingers)<span id = 1320></span>|62.1%|Hard|||
|1326|[Minimum Number of Taps to Open to Water a Garden](#1326-minimum-number-of-taps-to-open-to-water-a-garden)<span id = 1326></span>|43.0%|Hard|||
|1335|[Minimum Difficulty of a Job Schedule](#1335-minimum-difficulty-of-a-job-schedule)<span id = 1335></span>|57.1%|Hard|||
|1359|[Count All Valid Pickup and Delivery Options](#1359-count-all-valid-pickup-and-delivery-options)<span id = 1359></span>|57.6%|Hard|||
|1339|[Maximum Product of Splitted Binary Tree](#1339-maximum-product-of-splitted-binary-tree)<span id = 1339></span>|37.1%|Medium|||
|1340|[Jump Game V](#1340-jump-game-v)<span id = 1340></span>|57.3%|Hard|||
|1349|[Maximum Students Taking Exam](#1349-maximum-students-taking-exam)<span id = 1349></span>|40.9%|Hard|||
|1372|[Longest ZigZag Path in a Binary Tree](#1372-longest-zigzag-path-in-a-binary-tree)<span id = 1372></span>|53.6%|Medium|||
|1373|[Maximum Sum BST in Binary Tree](#1373-maximum-sum-bst-in-binary-tree)<span id = 1373></span>|41.0%|Hard|||
|1367|[Linked List in Binary Tree](#1367-linked-list-in-binary-tree)<span id = 1367></span>|39.5%|Medium|||
|1388|[Pizza With 3n Slices](#1388-pizza-with-3n-slices)<span id = 1388></span>|44.3%|Hard|||
|1402|[Reducing Dishes](#1402-reducing-dishes)<span id = 1402></span>|72.9%|Hard|||
|1397|[Find All Good Strings](#1397-find-all-good-strings)<span id = 1397></span>|37.1%|Hard|||
|1416|[Restore The Array](#1416-restore-the-array)<span id = 1416></span>|36.3%|Hard|||
|1406|[Stone Game III](#1406-stone-game-iii)<span id = 1406></span>|55.8%|Hard|||
|1411|[Number of Ways to Paint N × 3 Grid](#1411-number-of-ways-to-paint-n-×-3-grid)<span id = 1411></span>|61.4%|Hard|||
|1434|[Number of Ways to Wear Different Hats to Each Other](#1434-number-of-ways-to-wear-different-hats-to-each-other)<span id = 1434></span>|37.8%|Hard|||
|1420|[Build Array Where You Can Find The Maximum Exactly K Comparisons](#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons)<span id = 1420></span>|65.4%|Hard|||
|1423|[Maximum Points You Can Obtain from Cards](#1423-maximum-points-you-can-obtain-from-cards)<span id = 1423></span>|41.4%|Medium|||
|1449|[Form Largest Integer With Digits That Add up to Target](#1449-form-largest-integer-with-digits-that-add-up-to-target)<span id = 1449></span>|41.2%|Hard|||
|1444|[Number of Ways of Cutting a Pizza](#1444-number-of-ways-of-cutting-a-pizza)<span id = 1444></span>|52.4%|Hard|||
|1463|[Cherry Pickup II](#1463-cherry-pickup-ii)<span id = 1463></span>|64.6%|Hard|||
|1458|[Max Dot Product of Two Subsequences](#1458-max-dot-product-of-two-subsequences)<span id = 1458></span>|41.5%|Hard|||
|1478|[Allocate Mailboxes](#1478-allocate-mailboxes)<span id = 1478></span>|54.4%|Hard|||
|1477|[Find Two Non-overlapping Sub-arrays Each With Target Sum](#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum)<span id = 1477></span>|28.3%|Medium|||
|1473|[Paint House III](#1473-paint-house-iii)<span id = 1473></span>|47.7%|Hard|||
|1510|[Stone Game IV](#1510-stone-game-iv)<span id = 1510></span>|47.5%|Hard|||
|1504|[Count Submatrices With All Ones](#1504-count-submatrices-with-all-ones)<span id = 1504></span>|60.9%|Medium|||




## 5. Longest Palindromic Substring

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#5)

## 10. Regular Expression Matching

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#10)

## 32. Longest Valid Parentheses

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#32)

## 44. Wildcard Matching

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#44)

## 53. Maximum Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#53)

## 62. Unique Paths

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

机器人位于m x n网格的左上角（在下图中标记为“开始”）。

机器人只能在任何时间点上下移动。 机器人试图到达网格的右下角（在下图中标记为“完成”）。

有多少种可能的独特路径？

**Example**

```
Example 1:
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right

Example 2:
Input: m = 7, n = 3
Output: 28
```

---

### Cpp Solution
**分析：** 比较简单的动态规划问题，每个格只与上方和左方的状态有关，所以可以状态压缩到一维。

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#62)

## 63. Unique Paths II

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

机器人位于m x n网格的左上角（在下图中标记为“开始”）。

机器人只能在任何时间点上下移动。 机器人试图到达网格的右下角（在下图中标记为“完成”）。

现在考虑是否在网格中添加了一些障碍。 会有多少条独特的路径？

网格中的障碍物和空白区域分别标记为1和0。

注意：m和n最多为100。

**Example**

```
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

---

### Cpp Solution
**分析：** 作为上一题的followup，这道题也比较简单，只需要考虑到有障碍的情况就可以了。唯一需要注意题目返回值如果不为int，那么vector也需要跟着变。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& oG) {
        int m = oG.size(), n = oG[0].size();
        vector<int> dp(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int left = j ? dp[j-1] : 0;
                int up = i ? dp[j] : (j ? 0 : 1);
                dp[j] = oG[i][j] == 0 ? left + up : 0;
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#63)

## 64. Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

给定一个m×n的网格，其中填充了非负数，请找到一条从左上到右下的路径，该路径将沿其路径的所有数字的总和最小化。 

注意：您只能在任何时间点向下或向右移动。

**Example**

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

---

### Cpp Solution
**分析：** 同样是上一题的followup，注意的点是数据溢出和边界条件处理。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int left = j ? dp[j-1] : INT_MAX;
                int up = i ? dp[j] : (j ? 0 : INT_MAX);
                dp[j] = grid[i][j] + min(left, up);
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**重用矩阵, 边界问题先处理掉

```c
int minPathSum(int** grid, int gridSize, int* gridColSize){
    for (int i = 1; i < gridSize; ++i)
        grid[i][0] += grid[i-1][0];
    for (int k = 1; k < gridColSize[0]; ++k)
        grid[0][k] += grid[0][k-1];

    for (int i = 1; i < gridSize; ++i) {
        for (int j = 1; j < gridColSize[i]; ++j) {
            grid[i][j] += (grid[i-1][j] < grid[i][j-1] ? grid[i-1][j] : grid[i][j-1]);
        }
    }

    return grid[gridSize-1][(*gridColSize)-1];
}
```

[返回目录](#64)

## 70. Climbing Stairs

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

您正在爬楼梯。 它需要n步才能到达顶部。

每次您可以爬1或2步。 您可以通过几种不同的方式登顶？

**Example**

```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

---

### Cpp Solution
**分析：** 斐波那契数列问题，经典简单动态规划

```cpp
class Solution {
public:
    int climbStairs(int n) {
        int a = 0, b = 1;
        for (int i = 0; i < n; i++) {
            a += b;
            swap(a, b);
        }
        return b;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#70)

## 72. Edit Distance

Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

给定两个单词word1和word2，找到将word1转换为word2所需的最少操作数。

您可以对一个单词进行以下3个操作

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**Example**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

---

### Cpp Solution
**分析：** 也是很经典的一道动态规划hard的题目，可以状态压缩到一维。

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length(), n = word2.length();

        vector<int> dp(n+1, 0);
        for (int i = 0; i < n + 1; i++) dp[i] = i;

        int prev, cur;
        for (int i = 0; i < m; i++) {
            prev = dp[0]++;

            for (int j = 0; j < n; j++) {
                cur = dp[j+1];

                if (word1[i] == word2[j]) {
                    dp[j+1] = prev;
                } else {
                    dp[j+1] = 1 + min(prev, min(dp[j], dp[j+1]));
                }

                prev = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#72)

## 85. Maximal Rectangle

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#85)

## 87. Scramble String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#87)

## 91. Decode Ways

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#91)

## 95. Unique Binary Search Trees II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#95)

## 96. Unique Binary Search Trees

Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

给定n，多少个结构唯一的BST（二进制搜索树）存储值1 ... n？

**Example**

```
Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
int numTrees(int n) {
    int dp[n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = dp[1] = 1;

    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            dp[i] += dp[j] * dp[i-j-1];
        }
    }
    return dp[n];
}
```

[返回目录](#96)

## 97. Interleaving String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#97)

## 115. Distinct Subsequences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#115)

## 120. Triangle

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

**Example**

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<int> dp(triangle[n-1]);

        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);
            }
        }
        return dp[0];
    }
};
```

### C Solution
**分析：**

```c
int minimumTotal(int **triangle, int triangleSize, int *triangleColSize) {
    int min_path[triangleSize];

    int x, y;
    min_path[0] = triangle[0][0];
    for (int i = 1; i < triangleSize; ++i) {
        // 填最右边
        min_path[i] = triangle[i][i] + min_path[i - 1];

        // 中间
        for (int j = i - 1; j > 0; --j) {
            x = min_path[j - 1];
            y = min_path[j];
            min_path[j] = triangle[i][j] + (x < y ? x : y);
        }
        // 填最左边
        min_path[0] += triangle[i][0];
    }

    int res = INT32_MAX;
    for (int i = 0; i < triangleSize; ++i) {
        res = res < min_path[i] ? res : min_path[i];
    }
    return res;
}
```

[返回目录](#120)

## 121. Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

假设您有一个数组，第i个元素是第i天给定股票的价格。

如果只允许您最多完成一笔交易（即买入和卖出一股股票），请设计一种算法以找到最大的利润。

**Example**

```
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_p = INT_MAX, res = 0;
        for (auto& p: prices) {
            min_p = min(min_p, p);
            res = max(res, p - min_p);
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#121)

## 123. Best Time to Buy and Sell Stock III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#123)

## 132. Palindrome Partitioning II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#132)

## 139. Word Break

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#139)

## 140. Word Break II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#140)

## 152. Maximum Product Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#152)

## 174. Dungeon Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#174)

## 188. Best Time to Buy and Sell Stock IV

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#188)

## 198. House Robber

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#198)

## 213. House Robber II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#213)

## 221. Maximal Square

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#221)

## 256. Paint House

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#256)

## 264. Ugly Number II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#264)

## 265. Paint House II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#265)

## 276. Paint Fence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#276)

## 279. Perfect Squares

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#279)

## 300. Longest Increasing Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#300)

## 303. Range Sum Query - Immutable

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#303)

## 304. Range Sum Query 2D - Immutable

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#304)

## 309. Best Time to Buy and Sell Stock with Cooldown

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#309)

## 312. Burst Balloons

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#312)

## 321. Create Maximum Number

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#321)

## 322. Coin Change

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#322)

## 338. Counting Bits

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#338)

## 343. Integer Break

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#343)

## 351. Android Unlock Patterns

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#351)

## 354. Russian Doll Envelopes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#354)

## 357. Count Numbers with Unique Digits

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#357)

## 361. Bomb Enemy

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#361)

## 363. Max Sum of Rectangle No Larger Than K

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#363)

## 368. Largest Divisible Subset

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#368)

## 375. Guess Number Higher or Lower II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#375)

## 376. Wiggle Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#376)

## 377. Combination Sum IV

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#377)

## 392. Is Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#392)

## 403. Frog Jump

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#403)

## 410. Split Array Largest Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#410)

## 413. Arithmetic Slices

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#413)

## 416. Partition Equal Subset Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#416)

## 418. Sentence Screen Fitting

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#418)

## 446. Arithmetic Slices II - Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#446)

## 464. Can I Win

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#464)

## 466. Count The Repetitions

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#466)

## 467. Unique Substrings in Wraparound String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#467)

## 471. Encode String with Shortest Length

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#471)

## 472. Concatenated Words

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#472)

## 474. Ones and Zeroes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#474)

## 486. Predict the Winner

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#486)

## 494. Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#494)

## 514. Freedom Trail

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#514)

## 516. Longest Palindromic Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#516)

## 517. Super Washing Machines

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#517)

## 523. Continuous Subarray Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#523)

## 546. Remove Boxes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#546)

## 552. Student Attendance Record II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#552)

## 568. Maximum Vacation Days

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#568)

## 576. Out of Boundary Paths

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#576)

## 600. Non-negative Integers without Consecutive Ones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#600)

## 629. K Inverse Pairs Array

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#629)

## 638. Shopping Offers

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#638)

## 639. Decode Ways II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#639)

## 646. Maximum Length of Pair Chain

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#646)

## 647. Palindromic Substrings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#647)

## 650. 2 Keys Keyboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#650)

## 651. 4 Keys Keyboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#651)

## 656. Coin Path

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#656)

## 664. Strange Printer

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#664)

## 673. Number of Longest Increasing Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#673)

## 688. Knight Probability in Chessboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#688)

## 689. Maximum Sum of 3 Non-Overlapping Subarrays

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#689)

## 691. Stickers to Spell Word

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#691)

## 698. Partition to K Equal Sum Subsets

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#698)

## 712. Minimum ASCII Delete Sum for Two Strings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#712)

## 714. Best Time to Buy and Sell Stock with Transaction Fee

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#714)

## 718. Maximum Length of Repeated Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#718)

## 727. Minimum Window Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#727)

## 730. Count Different Palindromic Subsequences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#730)

## 740. Delete and Earn

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#740)

## 741. Cherry Pickup

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#741)

## 746. Min Cost Climbing Stairs

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#746)

## 750. Number Of Corner Rectangles

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#750)

## 764. Largest Plus Sign

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#764)

## 787. Cheapest Flights Within K Stops

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#787)

## 790. Domino and Tromino Tiling

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#790)

## 801. Minimum Swaps To Make Sequences Increasing

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#801)

## 808. Soup Servings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#808)

## 813. Largest Sum of Averages

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#813)

## 818. Race Car

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#818)

## 837. New 21 Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#837)

## 838. Push Dominoes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#838)

## 847. Shortest Path Visiting All Nodes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#847)

## 871. Minimum Number of Refueling Stops

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#871)

## 873. Length of Longest Fibonacci Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#873)

## 877. Stone Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#877)

## 879. Profitable Schemes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#879)

## 887. Super Egg Drop

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#887)

## 898. Bitwise ORs of Subarrays

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#898)

## 902. Numbers At Most N Given Digit Set

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#902)

## 903. Valid Permutations for DI Sequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#903)

## 920. Number of Music Playlists

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#920)

## 931. Minimum Falling Path Sum

Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.

给定整数A的方形数组，我们希望通过A的下降路径的总和最小。

下降路径从第一行的任何元素开始，并从每一行中选择一个元素。 下一行的选择必须在与上一行的列最多相差一列的列中。

**Example**

```
Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation: 
The possible falling paths are:
  * [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
  * [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
  * [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
The falling path with the smallest sum is [1,4,7], so the answer is 12.
```

**Constraints:**
- 1 <= A.length == A[0].length <= 100
- -100 <= A[i][j] <= 100

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& A) {
        vector<vector<int>> B(A);
        int n = B.size();

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                B[i][j] += min({B[i-1][max(0, j-1)],
                                B[i-1][j],
                                B[i-1][min(n-1, j+1)]});
            }
        }
        return *min_element(B[n-1].begin(), B[n-1].end());
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#931)

## 935. Knight Dialer

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#935)

## 940. Distinct Subsequences II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#940)

## 943. Find the Shortest Superstring

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#943)

## 956. Tallest Billboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#956)

## 960. Delete Columns to Make Sorted III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#960)

## 964. Least Operators to Express Number

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#964)

## 967. Numbers With Same Consecutive Differences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#967)

## 968. Binary Tree Cameras

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#968)

## 975. Odd Even Jump

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#975)

## 978. Longest Turbulent Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#978)

## 982. Triples with Bitwise AND Equal To Zero

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#982)

## 983. Minimum Cost For Tickets

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#983)

## 1000. Minimum Cost to Merge Stones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1000)

## 1055. Shortest Way to Form String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1055)

## 1058. Minimize Rounding Error to Meet Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1058)

## 1012. Numbers With Repeated Digits

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1012)

## 1066. Campus Bikes II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1066)

## 1067. Digit Count in Range

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1067)

## 1024. Video Stitching

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1024)

## 1025. Divisor Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1025)

## 1027. Longest Arithmetic Sequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1027)

## 1136. Parallel Courses

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1136)

## 1039. Minimum Score Triangulation of Polygon

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1039)

## 1048. Longest String Chain

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1048)

## 1049. Last Stone Weight II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1049)

## 1074. Number of Submatrices That Sum to Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1074)

## 1230. Toss Strange Coins

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1230)

## 1199. Minimum Time to Build Blocks

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1199)

## 1092. Shortest Common Supersequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1092)

## 1216. Valid Palindrome III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1216)

## 1105. Filling Bookcase Shelves

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1105)

## 1273. Delete Tree Nodes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1273)

## 1246. Palindrome Removal

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1246)

## 1259. Handshakes That Don't Cross

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1259)

## 1125. Smallest Sufficient Team

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1125)

## 1289. Minimum Falling Path Sum II

Given a square grid of integers arr, a falling path with non-zero shifts is a choice of exactly one element from each row of arr, such that no two elements chosen in adjacent rows are in the same column.

Return the minimum sum of a falling path with non-zero shifts.

给定一个整数的正方形网格，具有非零位移的下降路径可以选择arr每行中的一个元素，这样在相邻列中没有两个元素被选择在同一列中。

返回非零位移的下降路径的最小和。

**Example**

```
Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13
Explanation:
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is [1,5,7], so the answer is 13.
```

**Constraints:**

 - 1 <= arr.length == arr[i].length <= 200
 - -99 <= arr[i][j] <= 99

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    vector<int> find_1st_and_2nd_min(vector<int> &v)
    {
        vector<int> res = {-1, -1};
        int fmin = INT_MAX, smin = INT_MAX;
        for (int i = 0; i < v.size(); i++)
        {
            if (fmin > v[i])
            {
                smin = fmin;
                res[1] = res[0];
                fmin = v[i];
                res[0] = i;
            }
            else if (smin > v[i])
            {
                smin = v[i];
                res[1] = i;
            }
        }
        return res;

    }
    int minFallingPathSum(vector<vector<int>>& v) {
        int n = v.size();
        for (int i = n - 2; i >= 0; i--)
        {
            vector<int> res = find_1st_and_2nd_min(v[i+1]);
            for (int j = 0; j < n; j++)
            {
                v[i][j] += v[i+1][res[0] != j ? res[0] : res[1]];
            }
        }
        return *min_element(v[0].begin(), v[0].end());
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1289)

## 1130. Minimum Cost Tree From Leaf Values

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1130)

## 1301. Number of Paths with Max Score

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1301)

## 1139. Largest 1-Bordered Square

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1139)

## 1140. Stone Game II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1140)

## 1314. Matrix Block Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1314)

## 1143. Longest Common Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1143)

## 1147. Longest Chunked Palindrome Decomposition

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1147)

## 1155. Number of Dice Rolls With Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1155)

## 1363. Largest Multiple of Three

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1363)

## 1425. Constrained Subsequence Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1425)

## 1186. Maximum Subarray Sum with One Deletion

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1186)

## 1187. Make Array Strictly Increasing

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1187)

## 1483. Kth Ancestor of a Tree Node

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1483)

## 1191. K-Concatenation Maximum Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1191)

## 1405. Longest Happy String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1405)

## 1218. Longest Arithmetic Subsequence of Given Difference

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1218)

## 1220. Count Vowels Permutation

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1220)

## 1223. Dice Roll Simulation

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1223)

## 1235. Maximum Profit in Job Scheduling

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1235)

## 1240. Tiling a Rectangle with the Fewest Squares

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1240)

## 1227. Airplane Seat Assignment Probability

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1227)

## 1262. Greatest Sum Divisible by Three

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1262)

## 1269. Number of Ways to Stay in the Same Place After Some Steps

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1269)

## 1277. Count Square Submatrices with All Ones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1277)

## 1278. Palindrome Partitioning III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1278)

## 1312. Minimum Insertion Steps to Make a String Palindrome

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1312)

## 1320. Minimum Distance to Type a Word Using Two Fingers

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1320)

## 1326. Minimum Number of Taps to Open to Water a Garden

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1326)

## 1335. Minimum Difficulty of a Job Schedule

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1335)

## 1359. Count All Valid Pickup and Delivery Options

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1359)

## 1339. Maximum Product of Splitted Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1339)

## 1340. Jump Game V

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1340)

## 1349. Maximum Students Taking Exam

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1349)

## 1372. Longest ZigZag Path in a Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1372)

## 1373. Maximum Sum BST in Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1373)

## 1367. Linked List in Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1367)

## 1388. Pizza With 3n Slices

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1388)

## 1402. Reducing Dishes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1402)

## 1397. Find All Good Strings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1397)

## 1416. Restore The Array

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1416)

## 1406. Stone Game III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1406)

## 1411. Number of Ways to Paint N × 3 Grid

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1411)

## 1434. Number of Ways to Wear Different Hats to Each Other

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1434)

## 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1420)

## 1423. Maximum Points You Can Obtain from Cards

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1423)

## 1449. Form Largest Integer With Digits That Add up to Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1449)

## 1444. Number of Ways of Cutting a Pizza

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1444)

## 1463. Cherry Pickup II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1463)

## 1458. Max Dot Product of Two Subsequences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1458)

## 1478. Allocate Mailboxes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1478)

## 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1477)

## 1473. Paint House III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1473)

## 1510. Stone Game IV

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1510)

## 1504. Count Submatrices With All Ones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1504)
